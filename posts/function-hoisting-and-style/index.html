<!DOCTYPE html>
<html><head><title>function hoisting and style | Jason Pincin</title><link rel="stylesheet" href="http://yandex.st/highlightjs/8.0/styles/default.min.css"><link rel="stylesheet" href="/site.css"></head><body><div id="links"> <ul><li><a href="http://jason.pincin.com/">blog</a></li><li><a href="https://github.com/jasonpincin">github</a></li><li><a href="https://twitter.com/jasonpincin">@jasonpincin</a></li></ul></div><div id="header"> <h1>function hoisting and style</h1><sub>published by Jason Pincin on 2016-09-22 </sub></div><div id="main"><article id="article"><div><p>In my <a href="/posts/name-your-javascript-functions">last post</a>, I wrote about the importance of naming your Javascript functions and the impact it has on observability. This time around I'm going to diverge from factual presentation, and talk about oft-debated coding styles. Some (many?) of you won't agree with me, but I'm right. </p>
<h2 id="implementation-follows-intent">implementation follows intent</h2>
<p>Now that we're naming all of our functions, there's some stylistic patterns we can use to make our code more digestible by humans. The idea is to have intent lead implementation. When reading the code, the first thing we see it the logic of the immediate function, followed by any function definitions in this scope. This gives us a nice summary (self-documented through clear function names) with increasing detail as we continue to read a block of code. Let us look at some examples. First, let's see the opposite of the pattern I'm about to advocate:</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// accepts an array of numbers, returns the number of odd numbers</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">oddCount</span> (<span class="hljs-params">nums</span>) </span>{
    <span class="hljs-keyword">return</span> nums.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">num</span>) </span>{
        <span class="hljs-keyword">return</span> ((num % <span class="hljs-number">2</span>) === <span class="hljs-number">1</span>)
    }).length
}
</code></pre>
<p>There's obviously a myriad of other, some better, ways to implement this function, but I chose this implementation to illustrate a point that is applicable all over. Lets refactor the above function with two goals: name all functions, and lead implementation with intent for readability. </p>
<pre><code class="lang-javascript"><span class="hljs-comment">// accepts an array of numbers, returns the number of odd numbers</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">oddCount</span> (<span class="hljs-params">nums</span>) </span>{
    <span class="hljs-keyword">return</span> nums.filter(isOdd).length

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isOdd</span> (<span class="hljs-params">num</span>) </span>{
        <span class="hljs-keyword">return</span> ((num % <span class="hljs-number">2</span>) === <span class="hljs-number">1</span>)
    }
}
</code></pre>
<p>This is improved. Now when we read the <code>oddCount</code> implementation we're confronted with a single line of logic which reads very naturally, explaining to us exactly how it's working. It filters out what's not odd and gives us the length of the resulting array. Even in this very simplistic example, you can see how the latter approach is more easily digested than being confronted with the <code>oddCount</code> and <code>isOdd</code> implementations all at once in the previous example. The value of this approach only increases as code complexity increases. </p>
<p>But we can do better! Now that we've got a named filter function, we can also remove a closure here. Lets refactor one more time:</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// accepts an array of numbers, returns the number of odd numbers</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">oddCount</span> (<span class="hljs-params">nums</span>) </span>{
    <span class="hljs-keyword">return</span> nums.filter(isOdd).length
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isOdd</span> (<span class="hljs-params">num</span>) </span>{
    <span class="hljs-keyword">return</span> ((num % <span class="hljs-number">2</span>) === <span class="hljs-number">1</span>)
}
</code></pre>
<p>Unlike the anonymous function approach, we've now removed our <code>isOdd</code> function from the <code>oddCount</code> function, thereby eliminating a closure. This is a small performance boost and a win for readability. Win-win. </p>
<p>You may be thinking arrow functions make this all cleaner. What about this ES6-ish implementation?</p>
<pre><code class="lang-livecodeserver"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">oddCount</span> (<span class="hljs-title">nums</span>) {</span>
    <span class="hljs-constant">return</span> nums.<span class="hljs-built_in">filter</span>(<span class="hljs-built_in">num</span> =&gt; (<span class="hljs-built_in">num</span> % <span class="hljs-number">2</span>) === <span class="hljs-number">1</span>).<span class="hljs-built_in">length</span>
}
</code></pre><p>I would argue the preceding approach still wins hands-down over the arrow function style, in both readability and <a href="../name-your-javascript-functions">observability</a>. Not sure about you, but <code class="lang-stylus">nums.<span class="hljs-function"><span class="hljs-title">filter</span><span class="hljs-params">(isOdd)</span></span></code> is just less taxing for me to parse than <code class="lang-dart">nums.filter(<span class="hljs-built_in">num</span> =&gt; (<span class="hljs-built_in">num</span> % <span class="hljs-number">2</span>) === <span class="hljs-number">1</span>)</code> as I scan across the line.</p>
<h2 id="constructors-and-prototypes">constructors and prototypes</h2>
<p>Another readability win comes when using this pattern for constructor and prototypes. Lets dive right into an example:</p>
<pre><code class="lang-javascript"><span class="hljs-built_in">module</span>.exports = Rectangle

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Rectangle</span> (<span class="hljs-params">width, height</span>) </span>{
    <span class="hljs-keyword">this</span>.width = width
    <span class="hljs-keyword">this</span>.height = height
}

Rectangle.prototype.getPerimeter = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * (<span class="hljs-keyword">this</span>.width + <span class="hljs-keyword">this</span>.height)
}

Rectangle.prototype.getArea = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.width * <span class="hljs-keyword">this</span>.height
}
</code></pre>
<p>This is a very typical pattern. You've probably seen this example constructor a thousand times. The downfall of this style, is that in order to get an idea of my Rectangle's API, I need to scan through the entire codebase of this <code class="lang-css"><span class="hljs-tag">rectangle</span><span class="hljs-class">.js</span></code> file, or do a big comment at the top that basically duplicates what the code could tell me, or refer out to some README. Let's refactor this to follow the pattern we've been talking about in this post:</p>
<pre><code class="lang-javascript"><span class="hljs-built_in">module</span>.exports = Rectangle
<span class="hljs-built_in">Object</span>.assign(Rectangle.prototype, {
    getPerimeter,
    getArea
})

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Rectangle</span> (<span class="hljs-params">width, height</span>) </span>{
    <span class="hljs-keyword">this</span>.width = width
    <span class="hljs-keyword">this</span>.height = height
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getPerimeter</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * (<span class="hljs-keyword">this</span>.width + <span class="hljs-keyword">this</span>.height)
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getArea</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.width * <span class="hljs-keyword">this</span>.height
}
</code></pre>
<p>The style here may be a little different than what you're used to, but it accomplishes the exact same thing. More importantly, no matter how many methods I attach to Rectangle, or how complex those methods become, I retain a self-documented summary of exposed methods at the top of my file. As a developer, when I open this file up, I immediately get a pretty good idea of what features these Rectangle objects offer... and if I want more detail about a specific method, I can refer down (my editor likely has a shortcut to jump to that function's implementation). </p>
<h2 id="es6-classes">es6 classes</h2>
<p>You might be wondering if this style works with ES6+ classes. The short answer is no. ES6+ classes are <a href="https://github.com/tc39/proposal-class-public-fields/issues/35">no-good</a>, <a href="https://github.com/joshburgess/not-awesome-es6-classes">rotten</a>, and <a href="http://christianalfoni.github.io/javascript/2015/01/01/think-twice-about-classes.html">horrible</a>, in my not-so-humble opinion. There's a lot to love in ES6, but <code class="lang-coffeescript"><span class="hljs-class"><span class="hljs-keyword">class</span></span></code> doesn't make that list. </p>
<p>Seriously, read over those posts by others I just linked. There's a lot of good content, and suggestions on how to do things better in your codebase and avoid the <code class="lang-coffeescript"><span class="hljs-class"><span class="hljs-keyword">class</span></span></code> trap. </p>
<h2 id="conclusion">conclusion</h2>
<p>Coding styles are a hotly debated topic, and will remain so for all time. I have a lot of my own opinions on what makes good style (semi-colons suck, there I said it), but I don't typically try to evangelize them. In the case of what I discussed in this post though, I believe there's some concrete, very visible benefits with respect to readability and clarity. Would love to know if you find this useful, or if you despise me for writing it. Ping me <a href="https://twitter.com/jasonpincin">@jasonpincin</a>. </p>
</div></article></div><script src="http://localhost:35729/livereload.js"></script></body></html>